#!/usr/bin/env python
# -*- coding: utf-8 -*-
############################################################################
#
# MODULE:    i.desertf.national
# AUTHOR(S): Desertwatch-E consortium
#
# PURPOSE:   Trend analysis of the desertification susceptibility indicator
#
# COPYRIGHT: (C) 2011 by the GRASS Development Team
#
#   This program is free software under the GNU General Public
#   License (>=v2). Read I the file COPYING that comes with GRASS
#   for details.
#
#############################################################################
#%Module
#%  description: Calculates trend of the desertification susceptibility indicator over one period of time (between t0 and t1).
#%  keywords: raster, desertification
#%End
#%option
#%  key: imageone
#%  type: string
#%  multiple: no
#%  gisprompt: old,cell,raster
#%  description: Select desertification susceptibility indicator map (t0 map):
#%  required: yes
#%end
#%option
#%  key: imagetwo
#%  type: string
#%  multiple: no
#%  gisprompt: old,cell,raster
#%  description: Select desertification susceptibility indicator map (t1 map):
#%  required: yes
#%end
#%option
#%  key: output
#%  type: string
#%  description: Output name for raster map:
#%  required: yes
#%end


import grass.script as grass 
import os


def main():
    #Get projection units
    proj_units=get_projection_units()

    # Retrieve variables from user interface
    input1= options['imageone']
    input2= options['imagetwo']
    output= options['output']
	
    # Retrieve current LOCATION, GISDBASE, GISBASE and MAPSET
    source_mapset= grass.gisenv()['MAPSET']	    
    source_GISBASE = os.getenv('GISBASE')
	
	#Check if input input1 and input2 exists in same mapset
    if input1.find('@')==-1:
        input1=input1 + '@' + source_mapset		
    if input2.find('@')==-1:
        input2=input2 + '@' + source_mapset	
    if input1[input1.find('@')+1:] !=input2[input2.find('@')+1:]:
        grass.fatal(("Imagens seleccionadas para os parâmetros imageone e imagetwo pertencem a Mapsets/Escala diferentes. Por favor verifique mapas raster de entrada seleccionados."))
    t_mapset= input1[input1.find('@')+1:]

    #Check if t_mapset is Local, or Regional or National
    if t_mapset not in ['National','Regional','Local']:
           grass.fatal(("Os mapas de raster deverão apenas existir em Mapset/Escalas com nome National (Nacional), Regional e Local. Por favor verifique os mapas de entrada seleccionados."))                
    
    # Check if files exist in selected mapset
    try:
        check_images(input1,t_mapset)
    except:
        grass.fatal(("O mapa seleccionado para (imageone) não está disponível. Por favor verifique o mapa de entrada seleccionado."))        
    try:
        check_images(input2,t_mapset)
    except:
        grass.fatal(("O mapa seleccionado para (imagetwo) não está disponível. Por favor verifique o mapa de entrada seleccionado."))              
		   
    # Check if output name is a valid string    
    p=string_check(output)
    if p==-1:
        grass.fatal(("Foram detectados caracteres ilegais no nome de saida inserido. Altere o nome e tente de novo."))

    #Change mapset  
    if source_mapset != t_mapset:
    	p=grass.run_command("g.mapset", mapset = t_mapset, quiet=True)  	
        if p!=0:
           grass.fatal(("Não foi possível ao GRASS mudar para o Mapset National (Nacional). Verifique a sua existência ou direito de acesso."))		

    # Eliminate pre-existance output map
    eliminate_rastermaps([output])  
    
    #Define computational region
    try:	
        if proj_units=="meters":		
            if t_mapset=='National':
                t_srx='300'
            elif t_mapset=='Local':
                t_srx='60'
            elif t_mapset=='Regional':
                t_srx='3000'			 		
            grass.run_command("g.region", rast = [input1,input2], res= t_srx, quiet=True)
        else:
            region = grass.region()
            b_srx= region['nsres']
            b_sry= region['ewres']		   
            grass.run_command("g.region", rast = [input1,input2],  quiet=True)  		       
    except:
        grass.fatal(("Não foi possível ao GRASS definir uma região computacional. Por favor verifique os ficheiros de entrada seleccionados."))				       

    # Compute comparison
    try:
        grass.mapcalc("$out=if($i1>=0 & $i1<=1 & $i2>=0 & $i2<=1,$i2-$i1,null())",out=output, i1=input1, i2=input2) 		
    except:
        eliminate_rastermaps([output])
        grass.fatal(("Não foi possível calcular a tendência do indicador de susceptibilidade à desertificação. Por favor verifique o ficheiro de entrada seleccionado."))  		

	# Apply color table (DWE-IS defined color table)
    if not source_GISBASE:
        grass.warning(('Não foi possível detectar a localização do DWE-IS. Tente de novo e, caso o problema persista, reinstale o DWE-IS.'))
        grass.run_command('r.colors', map = output, rules = "grey", quiet=True)	
    else:
        color_path= source_GISBASE + "/dweis/color/trendcolor" 
        check_file= os.path.isfile(color_path)    			
        if check_file==True:
            p=grass.run_command('r.colors', map = output, rules = color_path, quiet=True)	
            if p!=0:			
                grass.warning(('Não foi possivel ao DWE-IS aplicar a tabela de cores ao mapa de tendências. Pode aplicar esta tabela manualmente ou tente novamente gerar este mapa.'))                              						
                grass.run_command('r.colors', map = output, rules = "grey", quiet=True)					
        else:
            grass.warning(("Não foi possível encontrar a tabela de cores aplicável ao mapa de tendências do indicador de susceptibilidade à desertificação. Tente de novo e, caso o problema persista, reinstale o DWE-IS."))              
            grass.run_command('r.colors', map = output, rules = "grey", quiet=True)			
		
    #Define computational region- back to origal set
    try:	
        if proj_units=="meters":		
            if t_mapset=='National':
                t_srx='30'
            elif t_mapset=='Local':
                t_srx='4'
            elif t_mapset=='Regional':
                t_srx='300'			 		
            grass.run_command("g.region", rast = [input1,input2], res= t_srx, quiet=True)
        else:
            grass.run_command("g.region", rast = [input1,input2], nsres=b_sry, ewsres=b_srx, quiet=True)  		       
    except:
        grass.warning(("Não foi possível ao GRASS definir uma região computacional de origem do DW-E."))				       

		
		
    grass.message((" "))
    grass.message((" "))
    grass.message((" "))	
    grass.message(("O mapa de tendência do indicador de susceptibilidade à desertificação foi produzido com sucesso.\n"))

def check_images(inputc,mapsetc):
    if inputc.find('@')==-1:	
       inputc=inputc + '@' + mapsetc
    else:
       if inputc[inputc.find('@')+1:]!=mapsetc:         
           grass.fatal(("Mapa raster %s não está disponível no Mapset/Escala de destino. Por favor verifique o ficheiro de entrada seleccionado.")%inputc)
    check_input= grass.find_file(inputc, element = 'cell', mapset=mapsetc)    	          
    if check_input['fullname'] =="":
       error_msg= "Mapa raster " + inputc + " não foi encontrado. Por favor verifique o ficheiro de entrada seleccionado."
       grass.fatal(_(error_msg))      		
	
	
def eliminate_rastermaps(raster_list):
# # # # # Eliminate raster maps without having to print warnings in Command output
    temp_list=['']
    for x in raster_list:
       p=grass.mlist_grouped('rast', pattern=x)	
       if len(p)>0:
            temp_list.append(x)	
    temp_list.remove('')
    nuldev = file(os.devnull, 'w+')			
    if len(temp_list)>0:
        grass.run_command("g.remove", flags = "f", quiet=True, rast=temp_list, stderr = nuldev)
    nuldev.close()
    return 0
	
def get_projection_units():
# # # # # Function to retrieve Location's Geo Units
    proj_location = grass.read_command('g.proj', flags = 'jf').strip()	
    if "XY location"==proj_location:
        grass.fatal(("Este módulo necessita de ser corrido numa Location projectada (encontrada: %s). Por favor altere a Location ou Projecção/Sistema de coordenadas geográficas.") % proj_location)
    location_param= proj_location.split(" ")
    if location_param.__contains__("+units=m")==True or location_param.__contains__("+proj=longlat")==False:           
        return "meters"
    else:
        return "other"	
	
def string_check(text):
# # # # #Function to check if preffix string includes any invalid strings/characters
    if text=="0" or text==".":
       return -1
    check_charact=[]
    check_charact=check_charact+[text.find(".")]
    check_charact=check_charact+[text.find("myscript.tmp")]		
    check_charact=check_charact+[text.find("~")]	
    check_charact=check_charact+[text.find("/")]
    check_charact=check_charact+[text.find("\\")]
    check_charact=check_charact+[text.find("\"")]
    check_charact=check_charact+[text.find("\'")]
    check_charact=check_charact+[text.find(" ")]			
    check_charact=check_charact+[text.find("@")]
    check_charact=check_charact+[text.find(",")]	
    check_charact=check_charact+[text.find(";")]	
    check_charact=check_charact+[text.find(":")]	
    check_charact=check_charact+[text.find("=")]
    check_charact=check_charact+[text.find("!")]	
    check_charact=check_charact+[text.find("?")]
    check_charact=check_charact+[text.find("%")]
    check_charact=check_charact+[text.find("$")]	
    check_charact=check_charact+[text.find("#")]	
    check_charact=check_charact+[text.find(">")]			
    check_charact=check_charact+[text.find("?")]		
    check_charact=check_charact+[text.find("{")]
    check_charact=check_charact+[text.find("}")]	
    check_charact=check_charact+[text.find("[")]
    check_charact=check_charact+[text.find("]")]		
    check_charact=check_charact+[text.find("+")]
    check_charact=check_charact+[text.find("*")]				    
    check_charact=check_charact+[text.find("-")]
    check_charact=check_charact+[text.find("&")]
    check_charact=check_charact+[text.find("%")]    
    check_charact=check_charact+[text.find("subclass")]		
    check_charact=check_charact+[text.find("LULC")]			
    check_charact=check_charact+[text.find("__")]				
    check_charact=check_charact+[text.find("ndvi")]					
    check_charact=check_charact+[text.find("B.")]			
	
    if max(check_charact)!=-1:
        return -1
    else:
        return 0			
   

if __name__ == "__main__":
    options, flags = grass.parser()
    main()
